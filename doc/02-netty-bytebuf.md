# Серия Netty: подробное объяснение ByteBuf в Netty
## Введение

Класс, используемый для переноса информации и связи в `Netty`, называется **ByteBuf**, Из названия видно, что это буферная 
область **Byte**, так каковы характеристики **ByteBuf**? Взглянем.

`Netty` предоставляет пакет `io.netty.buffer`, который определяет различные типы **ByteBuf** и производные от них типы.

Основой `Netty` Buffer является абстрактный класс **ByteBuf**. Другие классы Buffer в основном являются производными от 
этого класса. Этот класс также определяет общий тон `Netty` Buffer.

Давайте сначала посмотрим на **ByteBuf**:

```
public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
```

**ByteBuf** реализует интерфейс **ReferenceCounted**. Который представляет ссылочную 
статистику объекта. Когда создается новый экземпляр **ReferenceCounted**, он начинается со счетчика ссылок равному 1. 
Метод `retain()` увеличивает количество ссылок, а `release()` уменьшает количество ссылок. Если счетчик ссылок уменьшится 
до 0, объект будет явно освобожден, и доступ к освобожденному объекту обычно приведет к нарушению прав доступа.

Если объект, реализующий **ReferenceCounted**, является контейнером других объектов, реализующих ReferenceCounted, 
содержащиеся в нем объекты также будут освобождены с помощью функции `release()`, когда счетчик ссылок контейнера станет
равным 0.

Таким образом, **ByteBuf** — это **Comparable** объект, который может подсчитывать количество ссылок. 
Он обеспечивает механизм последовательного или случайного доступа к байтам.

> Обратите внимание, что хотя JDK имеет свой собственный класс **ByteBuffer**, **ByteBuf** в **Netty** является 
> своей реализацией **ByteBuffer**. Они не связаны.

## Создание буфера

**ByteBuf** является абстрактным классом и не может быть создан напрямую. Хотя для создания экземпляра можно использовать
подкласс **ByteBuf**, **Netty** не рекомендует это делать. **Netty** рекомендует использовать `io.netty.buffer.Unpooled`
для создания **ByteBuff**. 

**Unpooled** — это класс инструментов, который может выделять пространство, копировать или 
инкапсулировать операции для **ByteBuf**.

Вот пример создания нескольких разных **ByteBuf**:

```
   import static io.netty.buffer.Unpooled.*;

   ByteBuf heapBuffer    = buffer(128);
   ByteBuf directBuffer  = directBuffer(256);
   ByteBuf wrappedBuffer = wrappedBuffer(new byte[128], new byte[256]);
   ByteBuf copiedBuffer  = copiedBuffer(ByteBuffer.allocate(128));

```

Выше мы видели 4 различных метода построения буфера: обычный buf, прямой buf (directBuffer), завернутый buf (wrappedBuffer)
и скопированный буфер (copiedBuffer).

**Обычный буфер** (buffer) — это буфера кучи фиксированного размера, 

**Прямой буфер** (directBuffers) — это прямые буфера фиксированного размера.
Прямой буфера использует память вне кучи, устраняя необходимость копировать данные в ядро, поэтому он более эффективен,
чем обычные буфера.

**Обернутый буфер** (WrappedBuffer) — это буфер, который представляет собой представление одного или нескольких существующих
байтовых массивов и байтовых буферов. Любые изменения в содержимом исходного массива или буфера будут видны в обернутом 
буфере. Предусмотрены различные методы-оболочки, и все они называются wrappedBuffer(). Возможно, вы захотите внимательно
изучить методы, которые принимают varargs, если хотите создать буфер, состоящий из более чем одного массива, 
чтобы уменьшить количество копий в памяти.


**Скопированный буфер** (copiedBuffer) — это глубокая копия одного или нескольких существующих байтовых массивов, байтовых буферов или строки.
В отличие от обернутого буфера, между исходными данными и скопированным буфером нет общих данных. Предусмотрены различные
методы копирования, и все они называются copiedBuffer(). Также удобно использовать эту операцию для объединения нескольких
буферов в один буфер.

## Индексация произвольного доступа

Так же, как и обычный примитивный байтовый массив, **ByteBuf** использует индексацию с отсчетом от нуля.
Это означает, что индекс первого байта всегда равен 0, а индекс последнего байта всегда равен capacity - 1. 
Например, чтобы перебрать все байты буфера, вы можете сделать следующее, независимо от его внутренней реализации:

```
        ByteBuf buffer = heapBuffer;
        for (int i = 0; i < buffer.capacity(); i ++) {
            byte b = buffer.getByte(i);
            System.out.println((char) b);
        }

```

## Индексация последовательного доступа

ByteBuf предоставляет две переменные указателя для поддержки последовательных операций чтения и записи — readerIndex 
для операции чтения и writerIndex для операции записи соответственно. На следующей диаграмме показано, как буфер делится
на три области с помощью двух указателей:

Буфер разделен на три части: байты для отбрасывания, байты для чтения и байты для записи.

```
    +-------------------+------------------+------------------+
    | discardable bytes |  readable bytes  |  writable bytes  |
    |                   |     (CONTENT)    |                  |
    +-------------------+------------------+------------------+
    |                   |                  |                  |
    0      <=      readerIndex   <=   writerIndex    <=    capacity
```

На приведенном выше рисунке также показано отношение размера между readerIndex, writerIndex и capacity.

## Доступные для чтения байты (фактическое содержимое)

В этом сегменте хранятся фактические данные. Любая операция, имя которой начинается с **read** или **skip**, будет получать 
или пропускать данные в текущем readerIndex и увеличивать их на количество прочитанных байтов. Если аргументом операции 
чтения также является ByteBuf и индекс назначения не указан, то вместе с этим увеличивается и writerIndex указанного буфера.
Если содержимого недостаточно, возбуждается IndexOutOfBoundsException. Значение по умолчанию для вновь выделенного, 
обернутого или скопированного readerIndex буфера равно 0.

Вот пример чтения из буфера:

```
        // Iterates the readable bytes of a buffer.
        while (directBuffer.isReadable()) {
            System.out.println(directBuffer.readByte());
        }
```
## Доступные для записи байты

Этот сегмент представляет собой неопределенное пространство, которое необходимо заполнить. Любая операция, имя которой 
начинается с **write**, запишет данные в текущий writerIndex и увеличит их на количество записанных байтов. Если аргументом
операции записи также является ByteBuf и исходный индекс не указан, то readerIndex указанного буфера увеличивается вместе.
Если осталось недостаточно байтов, доступных для записи, возбуждается IndexOutOfBoundsException. Значение по умолчанию 
для writerIndex вновь выделенного буфера равно 0. Значение по умолчанию для упакованного или скопированного буфера 
writerIndex — это capacity буфера.

Вот пример записи в буфер:

```
        // Fills the writable bytes of a buffer with random integers.
        while (wrappedBuffer.maxWritableBytes() >= 4) {
            wrappedBuffer.writeInt(new Random().nextInt());
        }

```

## Отбрасываемые байты

Этот сегмент содержит байты, которые уже были прочитаны операцией чтения. Первоначально размер этого сегмента равен 0,
но его размер увеличивается до writerIndex по мере выполнения операций чтения. Прочитанные байты можно отбросить, 
вызвав discardReadBytes(), чтобы освободить неиспользуемую область, как показано на следующей диаграмме:

```
   BEFORE discardReadBytes()
 
       +-------------------+------------------+------------------+
       | discardable bytes |  readable bytes  |  writable bytes  |
       +-------------------+------------------+------------------+
       |                   |                  |                  |
       0      <=      readerIndex   <=   writerIndex    <=    capacity
       

   AFTER discardReadBytes()
 
       +------------------+--------------------------------------+
       |  readable bytes  |    writable bytes (got more space)   |
       +------------------+--------------------------------------+
       |                  |                                      |
  readerIndex (0) <= writerIndex (decreased)        <=        capacity
```


> Обратите внимание, что после вызова discardReadBytes() не гарантируется содержимое доступных для записи байтов. 
> Доступные для записи байты в большинстве случаев не перемещаются и даже могут быть заполнены совершенно разными данными
> в зависимости от базовой реализации буфера.

## Очистка индексов буфера

Вы можете установить как readerIndex, так и writerIndex в 0, вызвав clear(). Он не очищает содержимое буфера (например,
заполняет его 0), а просто очищает два указателя. Также обратите внимание, что семантика этой операции отличается от 
`ByteBuffer.clear()`.

```
   BEFORE clear()
 
       +-------------------+------------------+------------------+
       | discardable bytes |  readable bytes  |  writable bytes  |
       +-------------------+------------------+------------------+
       |                   |                  |                  |
       0      <=      readerIndex   <=   writerIndex    <=    capacity
 
 
   AFTER clear()
 
       +---------------------------------------------------------+
       |             writable bytes (got more space)             |
       +---------------------------------------------------------+
       |                                                         |
       0 = readerIndex = writerIndex            <=            capacity
```

## Поисковые операции

Для простого одно байтового поиска используйте indexOf(int, int, byte) и bytesBefore(int, int, byte). 

bytesBefore(byte) особенно полезен, когда вы имеете дело со строкой, заканчивающейся NUL . Для сложных поисков 
используйте forEachByte(int, int, ByteProcessor) с реализацией ByteProcessor.

## Отметить и сбросить

В каждом буфере есть два маркерных индекса. Один предназначен для хранения readerIndex а другой — для хранения writerIndex.
Вы всегда можете изменить положение одного из двух индексов, вызвав метод сброса. Он работает аналогично методам метки
и сброса в InputStream, за исключением того, что здесь нет ограничения на readlimit.

## Производные буферы

Вы можете создать представление существующего буфера, вызвав один из следующих методов:

```
duplicate()
slice()
slice(int, int)
readSlice(int)
retainedDuplicate()
retainedSlice()
retainedSlice(int, int)
readRetainedSlice(int)

```

Производный буфер будет иметь независимые readerIndex, writerIndex и маркера, в то время как он разделяет другое 
внутреннее представление данных, как это делает буфер NIO.
Если требуется совершенно новая копия существующего буфера, вместо этого вызовите метод copy() или Unpooled.copiedBuffer.

## Несохраненные и сохраненные производные буферы

>**Обратите внимание, что duplicate() , slice() , slice(int, int) и readSlice(int) НЕ вызывают метод continue( retain() для
возвращаемого производного буфера, и поэтому его счетчик ссылок НЕ будет увеличен**.

Если вам нужно создать производный буфер с увеличенным счетчиком ссылок, рассмотрите возможность использования 
retainedDuplicate(), reintenedSlice(), reintenedSlice(retainedSlice(int, int) и readRetainedSlice(int), которые могут 
возвращать реализацию буфера, производящую меньше мусора.

## Преобразование в существующие типы JDK

#### Байтовый массив

Если ByteBuf поддерживается массивом байтов (т. е. byte [] ), вы можете получить к нему доступ напрямую через метод 
array(). Чтобы определить, поддерживается ли буфер массивом байтов, следует использовать hasArray().

#### NIO-буферы

Если ByteBuf можно преобразовать в NIO ByteBuffer, который разделяет его содержимое (например, буфер просмотра), вы 
можете получить его с помощью **nioBuffer()**. Чтобы определить, можно ли преобразовать буфер в буфер NIO, используйте 
nioBufferCount().

> Возвращенный ByteBuffer является долей или копией существующего буфера, и изменение позиции и предела буфера после
> возврата не повлияет на исходный буфер.

#### Преобразование в строку

Различные методы toString(Charset) преобразуют ByteBuf в String . Обратите внимание, что toString() не является 
методом преобразования.

#### Потоки ввода/вывода

Пожалуйста, обратитесь к **ByteBufInputStream** и **ByteBufOutputStream**.

## Подведем итог

ByteBuf является базовой основой netty, и это объект-носитель передачи данных. Хорошо понимая ByteBuf, вы сможете 
понять идею дизайна **Netty**.