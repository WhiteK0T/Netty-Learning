# Серия Netty: подробное о Channel в Netty
## Введение

Канал — это мост, соединяющий ByteBuf и Event. Канал в netty предоставляет унифицированный API. Благодаря этому 
унифицированному API netty может легко подключаться к различным типам передачи, таким как OIO, NIO и т. д. 
Сегодня эта статья познакомит вас с использованием канала и некоторыми понятиями, связанными с каналом.

## Сведения о канале

Что такое канал? Канал — это мост между сетевым вводом и обработкой ввода-вывода. Вы можете использовать канал для 
оценки текущего состояния, независимо от того, открыт он или подключен, а также для оценки операций ввода-вывода, 
поддерживаемых текущим каналом. Вы также можете использовать ChannelPipeline для обработки сообщений в канале.

Сначала посмотрим на канал:

```
public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {
```

Вы можете видеть, что Channel — это интерфейс, который наследует три класса: AttributeMap, ChannelOutboundInvoker и 
Comparable. Comparable указывает, что этот класс можно использовать для сравнения. AttributeMap используется для хранения 
различных атрибутов канала. ChannelOutboundInvoker в основном отвечает за соединение и запись между Channel и внешним 
SocketAddress.

Взгляните на методы, определенные в канале:

![](https://img-blog.csdnimg.cn/c9b27ad3e0644fcc956f5d2cf904f223.png)

## Асинхронный ввод-вывод и ChannelFuture

ChannelFuture это - результат асинхронной операции ввода/вывода Channel.

Все операции ввода/вывода в Netty являются асинхронными. Это означает, что любые вызовы ввода-вывода будут возвращены
немедленно, без гарантии того, что запрошенная операция ввода-вывода была завершена в конце вызова. Вместо этого вам 
будет возвращен экземпляр ChannelFuture, который предоставит вам информацию о результате или состоянии операции ввода-вывода.

ChannelFuture либо незавершен, либо завершен. Когда начинается операция ввода-вывода, создается новый объект будущего.
Новое будущее изначально не завершено — оно не выполнено, не выполнено и не отменено, поскольку операция ввода-вывода
еще не завершена. Если операция ввода-вывода завершена успешно, с ошибкой или отменой, будущая операция помечается
как завершенная с более конкретной информацией, такой как причина сбоя. Обратите внимание, что даже отказ и отмена 
относятся к завершенному состоянию.

На следующем рисунке показана соответствующая диаграмма состояния ChannelFuture и состояния ввода-вывода:
![](https://img-blog.csdnimg.cn/6d6cc43e5bf94c078d03f0011b897076.png)

Предусмотрены различные методы, позволяющие проверить, завершена ли операция ввода-вывода, дождаться завершения и 
получить результат операции ввода-вывода. Это также позволяет вам добавлять ChannelFutureListener s, чтобы вы 
могли получать уведомления о завершении операции ввода-вывода.

**Предпочитайте addListener(GenericFutureListener) вместо await()**

Рекомендуется использовать **addListener(GenericFutureListener)** вместо **await()** везде, где это возможно, чтобы 
получать уведомления о завершении операции ввода-вывода и выполнять любые последующие задачи.

**addListener(GenericFutureListener)** не блокирует. Он просто добавляет указанный ChannelFutureListener в ChannelFuture,
и поток ввода-вывода уведомит слушателей, когда будет выполнена операция ввода-вывода, связанная с будущим. 
ChannelFutureListener обеспечивает наилучшую производительность и использование ресурсов, потому что он вообще не 
блокируется, но может быть сложно реализовать последовательную логику, если вы не привыкли к программированию, 
управляемому событиями.

Напротив, **await()** является блокирующей операцией. После вызова вызывающий поток блокируется до тех пор, пока 
операция не будет выполнена. Легче реализовать последовательную логику с помощью await(), но вызывающий поток блокируется
без необходимости до тех пор, пока операция ввода-вывода не будет выполнена, и существуют относительно большие затраты
на уведомление между потоками. Более того, существует вероятность тупиковой блокировки при определенных обстоятельствах,
которая описана ниже.

**Не вызывайте await() внутри ChannelHandler**

Вот два примера, один из которых является неправильной операцией, а другой - правильной операцией:

```
   // BAD - NEVER DO THIS
    @Override
   public void channelRead(ChannelHandlerContext ctx, Object msg) {
       ChannelFuture future = ctx.channel().close();
       future.awaitUninterruptibly();
       // Perform post-closure operation
   }

   // GOOD
    @Override
   public void channelRead(ChannelHandlerContext ctx, Object msg) {
       ChannelFuture future = ctx.channel().close();
       future.addListener(new ChannelFutureListener() {
           public void operationComplete(ChannelFuture future) {
               // Perform post-closure operation
           }
       });
   }

```
Несмотря на упомянутые выше недостатки, безусловно, есть случаи, когда удобнее вызывать await(). В таком случае убедитесь,
что вы не вызываете await() в потоке ввода-вывода. В противном случае будет возбуждено исключение 
BlockingOperationException, чтобы предотвратить тупиковую блокировку.

**Не путайте тайм-аут ввода-вывода и тайм-аут ожидания.**

Значение тайм-аута, которое вы указываете с помощью await(long), await(long, TimeUnit), awaitUninterruptibly(long) или 
awaitUninterruptibly(long, TimeUnit), вообще не связано с тайм-аутом ввода-вывода. Если время ожидания операции 
ввода-вывода истекло, будущее будет помечено как «завершенное с ошибкой», как показано на диаграмме выше. 
Например, время ожидания подключения должно быть настроено с помощью параметра транспорта:

```
  // BAD - NEVER DO THIS
  Bootstrap b = ...;
  ChannelFuture f = b.connect(...);
  f.awaitUninterruptibly(10, TimeUnit.SECONDS);
  if (f.isCancelled()) {
      // Connection attempt cancelled by user
  } else if (!f.isSuccess()) {
      // You might get a NullPointerException here because the future
      // might not be completed yet.
      f.cause().printStackTrace();
  } else {
      // Connection established successfully
  }

  // GOOD
  Bootstrap b = ...;
  // Configure the connect timeout option.
  b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);
  ChannelFuture f = b.connect(...);
  f.awaitUninterruptibly();
 
  // Now we are sure the future is completed.
  assert f.isDone();
 
  if (f.isCancelled()) {
      // Connection attempt cancelled by user
  } else if (!f.isSuccess()) {
      f.cause().printStackTrace();
  } else {
      // Connection established successfully
  }
```

## Иерархия каналов

Channel может иметь родителя в зависимости от того, как он был создан. Например, SocketChannel, который был принят 
ServerSocketChannel, вернет ServerSocketChannel в качестве родителя в parent().
Семантика иерархической структуры зависит от транспортной реализации, которой принадлежит Channel. Например, вы можете
написать новую реализацию Channel, создающую подканалы, которые совместно используют одно подключение к сокету,
как это делают BEEP и SSH.

## Освобождение ресурсов

Важно вызвать close() или close(ChannelPromise), чтобы освободить все ресурсы после того, как вы закончите работу с 
Channel. Это гарантирует, что все ресурсы высвобождаются надлежащим образом, т. е. файловые дескрипторы.

## Обработка событий

Канал отвечает за установление соединения, и установленное соединение может использоваться для обработки события 
ChannelEvent. Фактически, ChannelEvent обрабатывается определенными обработчиками каналов. А ChannelPipeline — это мост,
соединяющий канал и обработчик канала.
