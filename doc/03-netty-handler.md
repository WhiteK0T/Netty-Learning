## Серия Netty: обзор архитектуры Netty

## Введение

Чем же Netty так хороша, и какие усовершенствования она сделала на основе самого NIO JDK? Какова его архитектура и 
рабочий процесс?

## Схема сетевой архитектуры

Основная роль netty заключается в предоставлении простой инфраструктуры NIO, которую можно комбинировать с различными
протоколами верхнего уровня, чтобы в конечном итоге получить высокопроизводительные серверы. Ниже представлена схема 
архитектуры, представленная на официальном сайте netty:

![](https://img-blog.csdnimg.cn/dda8e9896b454c6f8c42300c1170a0c3.png)

Как видно из рисунка выше, ядро netty в основном разделено на три части, а именно **расширяемую модель событий**, 
**унифицированный API** и **мощный байтовый буфер**. Эти три характеристики — волшебное оружие Netty.

## Богатая организация данных буфера

Начиная с нижней структуры данных Buffer, Netty предоставляет пакет io.netty.buffer, который определяет различные типы 
ByteBuf-ов.

Основой Netty Buffer является абстрактный класс ByteBuf. Другие классы Buffer в основном являются производными от этого
класса. Этот класс также определяет общий тон Netty Buffer.

Цель переписывания Netty ByteBuf состоит в том, чтобы сделать ByteBuf нижнего уровня быстрее и более подходящим для 
расширения, чем тот, который поставляется с JDK. В частности, ByteBuf Netty работает быстрее, чем ByteBuffer в JDK, 
и в то же время его легче расширять, и вы можете настроить Buf в соответствии со своими потребностями. 
Кроме того, Netty имеет несколько встроенных составных типов буферов, поэтому можно добиться прозрачного нулевого 
копирования. Для динамических типов буферов он может быть расширен по запросу, как StringBuffer, который очень прост 
в использовании.

## Нулевая копия

Что такое нулевая копия? Нулевое копирование означает, что копия не делается, когда требуется копия. Мы знаем, что 
данные будут инкапсулированы в пакеты для передачи в процессе использования базового протокола для передачи. Когда 
передаваемые данные слишком велики, чтобы поместиться в один пакет, данные необходимо разделить. После того как узел 
назначения получит данные, он должен собрать полученные данные. Как правило, эта операция сборки выполняется над данными.

Например, как показано в следующем примере, базовая комбинация TCP-пакетов называется HTTP-пакетом верхнего уровня, 
но не копируется:

![](https://img-blog.csdnimg.cn/5cefd4a7dcf64051af18800c42605675.png)

Как именно вы его копируете? В предыдущей главе мы знаем, что netty предоставляет метод класса инструментов Unpooled,
в этом классе инструментов есть много методов в обертки, приведем несколько примеров:

```
 public static ByteBuf wrappedBuffer(byte[]... arrays) {
        return wrappedBuffer(arrays.length, arrays);
    }

public static ByteBuf wrappedBuffer(ByteBuf... buffers) {
        return wrappedBuffer(buffers.length, buffers);
    }

public static ByteBuf wrappedBuffer(ByteBuffer... buffers) {
        return wrappedBuffer(buffers.length, buffers);
    }
```

Вышеупомянутые три метода соответственно инкапсулируют массив байтов, ByteBuf и ByteBuffer,
Все эти методы являются _нулевым копированием_.

## Единый API

Вообще говоря, в традиционном API ввода-вывода JDK используемый API отличается в зависимости от типа передачи или 
протокола. Нам нужно разработать разные приложения для разных методов передачи, которые нельзя унифицировать. 
В результате плавной миграции не происходит, и при расширении программы требуется дополнительная обработка.

> Традиционный блокирующий ввод-вывод **OIO**, новый ввод-вывод Java можно назвать **NIO**, асинхронный ввод-вывод можно 
> назвать **AIO** и так далее.

И традиционный IO и NIO в JDK разделены. Если вы используете традиционный IO в начале, то когда количество ваших 
клиентов вырастет до определенного уровня и вы будете готовы перейти на NIO, вы обнаружите, что переключение очень 
сложно, т.к. они разрознены.

Чтобы решить эту проблему, Netty предоставляет унифицированный класс Channel для предоставления унифицированного API.

Сначала взгляните на методы, определенные в Channel:

![](https://img-blog.csdnimg.cn/82c99c6dc89c4dd19675b6b2079539f2.png)

Из приведенного выше рисунка видно, что канал можно использовать для оценки текущего состояния канала, настройки его 
параметров и выполнения на нем операций ввода-вывода, а ChannelPipeline, связанный с каналом, используется для обработки
запросов ввода-вывода и событий, связанных с каналом.

Использование канала может обеспечить хорошую поддержку TCP/IP NIO, TCP/IP OIO, UDP/IP OIO и локальной передачи.

Переключение режима передачи требует лишь замены с небольшими затратами.

Конечно, если вас не устраивает существующая реализация, вы также можете сделать собственные расширения для основного API.

## Управляемый событиями

Netty — это управляемая событиями платформа. Основой событийной среды является модель событий. Netty определяет очень 
эффективную событийную модель для ввода-вывода. Вы можете реализовать свои собственные типы событий, не нарушая 
существующий код. Пользовательские типы событий в Netty отличаются от других типов событий строгой иерархией типов, 
поэтому они легко расширяемы.

Управление событиями в Netty является результатом совместного действия ChannelEvent, ChannelHandler и ChannelPipeline. 
Среди них ChannelEvent представляет произошедшее событие, ChannelHandler определяет, как обрабатывать событие, а 
ChannelPipeline подобен перехватчику, который позволяет пользователям самостоятельно управлять определенным 
ChannelHandler, чтобы достичь результата управления обработкой события.

Давайте посмотрим на простой пользовательский обработчик:

```
public class MyHandler extends SimpleChannelInboundHandler<Object> {

    @Override
    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
        // process the message
        ByteBuf in = (ByteBuf) msg;
        try {
            log.info("Received the news:{}", in.toString(CharsetUtil.UTF_8));
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        //exception handling
        cause.printStackTrace();
        ctx.close();
    }
}
```

В приведенном выше примере мы определили, как обрабатывать полученные сообщения и исключения. В последующих главах 
мы подробно расскажем о взаимодействии между ChannelEvent, ChannelHandler и ChannelPipeline.

## Другие замечательные функции

В дополнение к трем основным функциям, упомянутым выше, у Netty есть несколько других преимуществ, которые облегчают 
развитие программистов.

Например, поддержка SSL/TLS, реализация протокола HTTP, реализация WebSockets и Google Protocol Buffers и т. д. 
показывают, что Netty обладает мощными возможностями приложения в различных аспектах и сценариях.

## Подведем итог

Netty состоит из трех основных компонентов: буфера, канала и модели событий. Понимая, как эти три основных компонента 
работают друг с другом, нетрудно понять расширенные функции, построенные на Netty.